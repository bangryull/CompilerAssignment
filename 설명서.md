# MiniC 컴파일러 프로젝트 설명서

## 1. 프로젝트 개요

본 프로젝트는 MiniC 형태의 간단한 C-like 언어를 직접 설계하고,  
Lexer(Flex) → Parser(Bison) → AST 생성 → x86-64 Assembly 코드 생성까지의  
컴파일러 전체 파이프라인을 구현하는 것을 목표로 한다.

구현 방식은 다음과 같다:

- **어휘 분석(Lexer)**: Flex를 사용하여 토큰을 분류
- **구문 분석(Parser)**: Bison을 사용해 문법을 정의하고 AST 생성
- **AST(Abstract Syntax Tree)**: 언어의 구조를 표현
- **중간 표현 / 실행 방식**: x86-64 Linux SysV ABI 기반 어셈블리 코드 생성
- **실행**: GCC를 통해 어셈블리 → 바이너리로 빌드 후 실행

본 프로젝트는 학습 목적이며, 리눅스 환경에서만 실행 가능하도록 설계되었다.

---

## 2. 언어 설계 의도

MiniC 언어는 C와 유사한 구조를 가지지만 교육용으로 단순화되어 있다.

설계 목표는 다음과 같다:

- 직관적이고 배우기 쉬운 문법
- 스택 기반 함수 호출 구조 학습
- AST 및 컴파일러 구조 파악
- 실제 x86-64 어셈블리 코드 생성 경험

---

## 3. 문법 정의 (EBNF)

MiniC 언어의 전체 문법 정의는 다음과 같다:

```ebnf
program         = function_list ;

function_list   = { function } ;

function        = "int" identifier "(" param_list_opt ")" compound_stmt ;

param_list_opt  = | param_list ;
param_list      = "int" identifier { "," "int" identifier } ;

compound_stmt   = "{" stmt_list_opt "}" ;
stmt_list_opt   = | stmt_list ;
stmt_list       = stmt { stmt } ;

stmt            = vardecl ";"
                | assign ";"
                | "return" expr ";"
                | expr ";" ;

vardecl         = "int" identifier ;

assign          = identifier "=" expr ;

expr            = expr "+" expr
                | expr "-" expr
                | expr "*" expr
                | expr "/" expr
                | primary ;

primary         = number
                | identifier
                | identifier "(" arg_list_opt ")"
                | "(" expr ")" ;

arg_list_opt    = | arg_list ;
arg_list        = expr { "," expr } ;
```

---

## 4. 전체 구조(Compiler Pipeline)

```
MiniC Source
      ↓
   Lexer (Flex)
      ↓
 Tokens
      ↓
   Parser (Bison)
      ↓
 AST(Abstract Syntax Tree)
      ↓
 Code Generator (x86-64)
      ↓
 out.s (Assembly)
      ↓
gcc -no-pie out.s -o prog
      ↓
 Executable Program
```

### ✔ Lexer(Flex)

- 공백/개행 무시
- 키워드: int, return
- 식별자, 숫자, 연산자, 구분자 처리
- 에러 문자는 위치와 함께 출력

### ✔ Parser(Bison)

- EBNF 기반 문법 정의
- AST 생성
- 잘못된 문법에 대한 오류 메시지 출력

### ✔ AST

구조 예시:

```
Expr
 ├── EXPR_INT
 ├── EXPR_VAR
 ├── EXPR_BINOP
 └── EXPR_CALL

Stmt
 ├── STMT_VARDECL
 ├── STMT_ASSIGN
 ├── STMT_RETURN
 └── STMT_EXPR

Function
 ├── name
 ├── params
 └── stmt_list
```

### ✔ Code Generation (x86-64 SysV ABI)

- 함수 호출 규약: rdi, rsi, rdx 순으로 인자 전달
- 스택 프레임:
  - pushq %rbp
  - movq %rsp, %rbp
  - local variable allocation
- 연산 결과는 rax 사용
- return 시 rax가 반환값

예시:

```asm
movq -8(%rbp), %rax
pushq %rax
movq -16(%rbp), %rax
popq %rcx
addq %rcx, %rax
```

---

## 5. 테스트 프로그램 및 목적

총 10개 이상의 MiniC 테스트 프로그램을 작성하였다.

| 파일명 | 목적 | 기대 결과 |
|--------|------|-----------|
| add2.minic | 기본 함수 호출 / 덧셈 | 7 |
| mul.minic | 곱셈 연산 테스트 | 12 |
| call_chain.minic | 함수 내부에서 다른 함수 호출 | 정상 실행 |
| var_assign.minic | 변수 선언 및 대입 동작 | 정상 |
| return_only.minic | return 동작 테스트 | 값 반환 |
| expr_priority.minic | 연산자 우선순위 테스트 | 계산 결과 |
| nested_expression.minic | 괄호 사용 테스트 | 정확한 계산 |
| zero_test.minic | 0 값 처리 | 정상 |
| negative_test.minic | 음수 처리 | 정상 |
| large_value.minic | 큰 정수 계산 | 정상 |

---

## 6. 실행 결과 스크린샷

실행 예시:

```
./minic_x86 test/add2.minic
gcc -no-pie out.s -o prog
./prog
echo $?
7
```

(이미지는 PDF에 삽입)

---

## 7. 구현된 기능 / 미구현 기능

### ✔ 구현됨
- 변수 선언 및 대입
- 산술 연산 (+ - * /)
- 함수 정의 및 호출
- return 문
- AST 기반 구조
- x86-64 어셈블리 코드 생성
- 기본 오류 메시지 출력

### ❌ 미구현
- if / while / for 문
- 비교 연산자 (< > == != 등)
- 논리 연산자 (&& ||)
- 다중 파일 지원
- 타입 시스템

---

## 8. 향후 개선 방향

- 조건문 및 반복문 추가
- 중간 코드(IR) 추가 후 최적화
- JIT 컴파일러(LLVM) 사용
- 정적 분석 및 타입 검사기 구현
- 인터프리터 모드 추가

---

## 9. 결론

본 프로젝트는 직접 언어를 설계하고,  
Lexer → Parser → AST → Codegen → 실행이라는  
컴파일러의 전체 흐름을 직접 구현함으로써  
언어 처리기의 내부 구조를 깊이 이해하는 데 큰 도움이 되었다.

---

## 부록 A — 전체 코드 구조

```
include/
  ast.h
  codegen_x86.h

src/
  ast.c
  codegen_x86.c
  main.c
  lexer.l
  parser.y

test/
  *.minic
```

---

## 부록 B — 예제 코드 (add2.minic)

```c
int add(int a, int b) {
    int s;
    s = a + b;
    return s;
}

int main() {
    int x;
    int y;
    int result;
    x = 3;
    y = 4;
    result = add(x, y);
    return result;
}
```
